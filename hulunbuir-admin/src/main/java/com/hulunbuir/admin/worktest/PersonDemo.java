package com.hulunbuir.admin.worktest;

/**
 * <p>
 * Explain:java基础知识
 * </p >
 *
 * @author wangjunming
 * @since 2020-03-08 15:11
 */
public class PersonDemo {

    static {
        System.out.println("执行类的静态方法!!!");
    }

        /**

         继承：
            子父类中的继承：
         构造函数：
         子父类中的构造方法：
         在对子类对象进行初始化的时候，父类的构造函数也会运行
         因为其子类的构造函数默认的隐式语句super();
         如果父类中没有空的构造参数
         子类的所有的构造函数，默认都会访问父类中的默认构造函数
         其子类的构造函数第一行默认的隐式语句super();

         子类一定要访问父类的构造函数：
         因为父类中的数据子类可以直接获取，所以子类对象在建立时，
         需要先查看父类是如何对这些数据进行初始化，
         所以子类在对象初始化时，要先访问一下父类中的构造函数。
         如果要访问父类中指定的构造函数可以通过手动定义super函数语句的方式来指定

         注意：super语句一定要定义在子类构造函数的第一行

         子类中所有的构造函数，默认都会访问父类的空构造函数，
         因为子类的每一个构造函数内的第一行都有一句隐式super();
         当父类中没有空参数的构造函数是，子类必须手动通过super语句形式来指定要访问父类中的构造函数

         当然：
         子类的构造函数第一行也可以手动的指定this语句来访问本类中的构造函数。
         子类中至少会有一个构造函数会访问父类中的构造函数。

         变量：
         如果子类中出现非私有同名成员变量时
         子类要访问本类中的变量，用this
         子类要访问父类中的同名变量时，用super
         super的使用和this的使用几乎一致
         this代表的是本类对象的引用
         super代表的是父类对象的引用

         函数：
         当子类出现和父类一模一样的函数时
         当子类对象调用该函数，会运行子类函数的内容
         如同父类的函数被覆盖一样
         这种情况是函数的另一个特性：重写（覆盖）

         当子类继承父类，沿袭了父类的功能，到子类中，
         但是子类虽具备该功能，但是功能的内容却和父类中不一致
         这是，没有必要定义新功能，二十使用覆盖的特殊，保留父类的功能定义，并重写功能内容

         子父类中的覆盖：
         1. 子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败
         2. 静态只能重写(覆盖)静态
         重载：发生在类中的多个方法，方法名相同，参数列表不同
         重写（覆盖）：子父类方法要一模一样，其方法内容不一样

         final关键字：修饰符，最终的意思
         1、可以修饰类，函数，变量。
         2、被final修饰的类不可以被继承，为了避免被继承，被子类复写功能
         3、被final秀海的方法不可以被复写
         4、被final修饰的变量是一个常量，只能赋值一次，既可以修饰成员变量，又可以修饰局部变量
            当描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这些值起个名称，
         方便于阅读，而这个值不需要改变，所以加上final修饰，作为常量，常量的书写规范所有字母都大写，
         如由多个单词组成，单词间使用  “_” 下划线链接
         5、内部类定义在类中的局部位置上时，只能访问该局部被final修饰的局部变量。

         抽象类：
         当多个类中出现了相同的功能，但是功能的主体不同。(通过问题进行分析)
         这时可以进行向上抽取，这时，只抽取功能的定义，而不抽取功能主体。

         抽象，即看不懂，代码上没有具体的实现。
         abstract只能修饰类和方法

         抽象类的特点：
         抽象方法一定在抽象类中。
         抽象方法和抽象类都必须被abstract关键字修饰。
         抽象类不可以使用new关键字创建对象，因为调用抽象方法没有意义。
         抽象类中的方法要被使用，必须由子类复写其所有的抽象方法后，简历子类对象调用
             如果子类支付该了部分抽象方法，那么该子类还是抽象类

         抽象类和一般类没有太大的不同。
         应该该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。
         这些不确定的部分也是该事物的功能，需要明确出现，但是无法定义主体的实现。
         通过抽象类来表示。

         抽象类比一般类多了抽象函数，就是在类中可以定义抽象方法。
         抽象类不可以实例化。
         抽象类中可以不定义抽象方法。

         接口：
             可以认为是一个特殊的抽象类，
           当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示
         class用于定义类
         interface用于定义接口

         接口定义时，格式特点：
          接口中常见定义：常量，抽象方法。
          接口中的成员都有固定修饰符。
            常量默认使用：public static final
            方法默认使用:  public abstract

         接口是不可以创建对象的，因为有抽象方法。
         需要被子类实现，子类对接口中的抽象方法全部覆盖后，子类才可以实例化，
         否则子类是一个抽象类。

         接口可以被类多实现，也是对多继承不支持的转换形式，java支持多实现，即一个类可以同时实现多个接口

         只有在接口与接口之间可以有多继承关系


         多态：
         可以理解为事物存在多种体现形式，即动物可以包括猫，狗

         多态的体现：
            父类的引用指向了自己的子类对象。
            父类的引用也可以接受自己的子类对象。
         多态的前提：
            必须是类与类之间有关系，要么是继承，要么是实现。
            存在覆盖（类与类之间的重写，类与接口之前的重载），
         多态的好处：
            多态的出现大大的提高程序的扩展性。
         多态的弊端：
            提高了扩展性，但是只能使用父类的引用访问父类中的成员。
         多态的应用：
            多态中成员函数的特点：
         在编译时期：参阅引用型变量所属的类中是否有调用的方法，如果有，编译通过，如果没有则编译失败
         在运行时期：参阅对象所属的类中是够有调用的方法。
         简单总结就是：成员函数在多态调用时，编译看左边，运行看右边。

         在多态中，
         成员变量、成员函数的特点：
          无论编译和运行，都参考左边（引用变量所属的类）。
          例如：Anmail an = new Cat();
                an.eat();  这个时候执行的则是引用变量所属的类
         静态成员函数的特点：
          无论编译和运行，都参考左边。

         equals：
         Object类中已经提供了对对象是够相同的比较方法。

         如果自定义类中也有比较相同的功能，没有必要重新定义。
         只要沿袭父类中的功能，简历自己特有比较内容即可 ，这就是重写（覆盖）。
    ----------------------------------------------------------------------
         异常：对问题的描述，将问题进行对象的封装
            就是程序在运行时出现不正常情况。
         异常的由来：就是java对不正常的情况进行描述后的对象提现
         对于问题的划分：两种，一种是严重的问题，一种非严重的问题
         对于严重的，java通过error类进行描述。
             对于error一般不编写针对性的代码进行处理
         对于非严重的，java通过exception类进行描述。
             对于exception可以使用针对性的处理方式进行处理。
         无论error或者exception都有公共的类throwable

         异常的处理格式：
       1. try {
            try将可能发生异常的代码进行编写
            System.out.println("try");
         } catch (Exception e) {
            catch来进行捕获异常，针对不同的异常进行不同的处理
            System.out.println("catch"+e);
         }finally {
            finally用于将资源进行释放
            System.out.println("finally");
         }

         声明异常：throws Exception,异常类
          便于提高安全性，让调用处进行处理，不处理则编译失败。

         对异常的处理：
         1.声明异常时，建议声明更为具体的异常，这样梳理的可以更具体。
         2. 对反声明几个异常，就对应有几个catch块，不要定义多余的catch块。
          如果多个catch块中的异常出现继承关系，父类异常catch块方法最下面

         在进行catch处理时，catch中一定要定义具体处理方式：
         不要简单的定义一句输出语句，

        自定义异常（在业务中出现的异常并没有在java中所定义出来，所以需要自定义异常）：
         1.继承Exception(或者继承throwable体系中的类，必须的)
            原因：异常体系有一个特点：因为异常类和异常对象都被抛出
            因为具备可抛性，这个可抛性是throwable这个体系中独有特点
            只有这个体系中的类和对象才可以被throws和throw

         2.使用自定义异常：在方法中的 throw 自定义异常类名   进行抛出异常

         3.在函数方法上(即小括号和大括号之间)进行声明： throws  自定义异常类名

         特殊的RuntimeException异常类，运行时异常：
         如果在函数内进行抛出该异常，函数上可以不用声明，编译通过。
         如果在函数上声明了该异常，调用者可以不用进行处理，编译通过。
         之所以不用在函数上声明，是因为不需要调用者处理。
         当该异常发生，希望程序停止，因为在运行时，出现了无法继续运算的情况，希望停止程序。
         由程序员对代码进行修正。
         一旦出现此异常，则表示编译失败，该异常是可以被处理的。

         异常分两种：
            编译时不被检测的异常（运行时异常，RuntimeException以及其子类）。
            编译时被监测的异常。
                一旦出现异常则程序被停止

         catch代码块：
         适用于处理异常，如果没有catch就代表异常没有被处理过，如果该异常是检测时异常，那么必须进行声明

         finally代码块：是指异常中一定会被执行的代码
                通常用于关闭资源，释放资源
         当执行到System.exit(0);则finally不会执行


         异常在子父类覆盖中的体现：
            1. 子类在覆盖父类时，如果父类的方法抛出异常，
                   那么子类的覆盖方法，只能抛出父类的异常，或者该异常的子类。
            2. 如果父类方法抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集

            3. 如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常
                 如果子类方法发生了异常，就必须要进行try处理，决不能抛出异常

         异常的好处
          1. 将问题进行封装，
          2. 将正常流程代码和问题处理代码相分离，方便于阅读

    ------------------------------------------------------------------------

     多线程：
         进程：正在进行中的程序，每一个进程执行都有一个执行顺序，该顺序是一个执行路径。
         线程：就是进程中的一个独立的控制单元。
              线程在控制这进程的执行。
         一个进程中至少有一个线程。

         执行过程：
         java VM 启动的时候会有一个进程，java.exe
         该进程中至少会有一个线程负责java程序的执行
         而且这个线程运行的代码存在于main方法中，
         该线程称之为主线程。

         扩展，更细节的说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。


         创建线程：
            1.定义一个thread的子类
            2.重写run方法，创建线程
                 目的将自定义的代码存储在run方法中，让线程去调用
            3.new 子类对象.start(); 创建并启动线程，调用start方法，执行run方法

         其基本原理：
         因为多个线程都获取cpu的执行权，cpu执行到谁，谁就运行，明确一点，在某一时刻，
         只能有一个程序在运行，cpu在做着快速的切换，以达到看上去是同事运行的效果。
         我们可以形象的把多线程的运行行为在互相抢夺cpu的执行权。
         这就是多线程的一个特性，随机性，谁抢到谁执行，至于执行多长时间，cpu说的算。

         为什么要覆盖run方法：
            Thread类用于描述线程。
            其中run方法：用于存储线程要运行的代码，仅仅是对象调用方法，而线程创建了，并没有运行。
            其中start方法：用于调用线程的run方法，开启线程并执行该线程的run方法。

         线程的状态：
         被创建-->start-->运行-->sleep(time)(睡眠)-->冻结-->
                                time时间到-->开始运行(具备运行资格)
                                wait()等待-->冻结-->
                                notify()唤醒-->开始运行(具备运行资格)
                 -->stop();停止线程;(消亡)
                 -->run方法结束;(消亡)。

         Thread.currentThread()-->可以获取当前线程对象。
         其中的变量都是在线程中有独立空间进行存储

     创建线程，实现runnable接口步骤：
         1.定义类实现Runnable接口。
         2.覆盖runnable接口中的run方法。
             就是将线程要运行的代码存放在该run方法中。
         3.通过thread类简历线程对象。
         4.将runnable接口的子类对象作为实际参数传递给thread类的构造函数。
             为什么要将runnable接口的子类对象传递给thread的构造函数。
             因为，自定义的run方法，所属的对象是runnable接口的子类对象。
             所以要让线程去指定对象的run方法，就必须明确该run方法所属对象。

         5.调用thread类的start方法开启线程并调用runnable接口子类的run方法。

     实现接口方式，和继承方式有什么区别呢？
         实现接口方式的好处：避免了单继承的局限性。
         在定义线程时，建议使用实现方式。提高扩展性。

     两种方式区别：
         继承thread：线程代码存放在thread子类的run方法中。
         实现runnable：线程代码存在接口的子类的run方法中。

     其中最为常见的是使用实现runnable接口，并重写run方法。


         当实现了runnable接口的时候会出现了安全问题？
         问题的原因：
             当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，
             另一个线程就参与进来执行，导致共享数据的错误。
         解决办法：
             对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。

         java对于多线程的安全问题提供了专业的解决方式，
         同步代码块：
         synchronized(对象){同步代码块}
            其基本原理：
              对象如同锁，持有锁的线程可以在同步代码块中执行。
              没有持有锁的线程即使获取到了cpu的执行权，也进不去，因为没有获取锁
         例如：火车上的卫生间

         同步的前提：
             1.必须要有两个或者两个以上的线程。
             2.必须是多个线程使用同一个锁。
             3.必须保证同步中只能有一个线程在运行。

         好处：解决了多线程的安全问题
         弊端：多个线程需要判断锁，较为消耗资源

         同步有两种实现方式，
         同步代码块，同步函数

         什么时候使用同步？
         1.明确那些代码是多线程运行代码。
         2.明确共享数据。
         3.明确多线程运行代码中哪些语句是操作共享数据的。

         同步块的锁是：
         --任意的，创建出来的对象实例
         同步函数的锁是：
         --是当前的对象，也就是this
         静态同步函数锁是：
         --因为是静态的，随着类的加载而加载，所以锁是：当前类名.class

    ---------------------------------------------------------------------------------

         集合：
            为什么出现集合类？
         面向对象语言对事物的天都是一对象的形式，所以为了方便对多个对象的操作，就是对对象进行存储，
         集合就是存储对象最常用的一种方式。
            数据与集合类的不同？
         数据虽然也可以存储对象，但是长度固定，
         集合长度是可变的，数组中可以存储基本数据类型，集合只能存储对象。
            集合的特点？
         集合只用于存储对象，集合的长度是可变的，集合可以存储不同类型的对象。

         因为每个容器的存储方式不同，这种存储方式成为：数据结构

        Collection
            list
              元素是有序(存入的和取出的一样标识有序)的，并且元素可以重复，因为该集合中的数据有索引。
              在判断其中元素是否相同的时候只依赖equals方法，
              list集合中特有的迭代器：
              listIterator是Iterator的子接口，
              因为在迭代时，只能用迭代器的方法操作元素，可是Iterator的方法是有限的，
              只能对元素进行判断，取出，删除的操作，
              如果想要其他的操作，如，添加，修改的等，就需要使用其子接口：ListIterator。
                arraylist：
                    底层的数据结构是使用的是数组结构，特点：查询速度很快，但是增删较慢。线程不同步
                    源码解释（主要用于加深了解，当做是面试的敲门砖）：
                        arraylist为什么可以存放任意数量的对象，长度不受限制，那么它是怎么实现的？
                        默认长度10,

                linkedlist：
                    底层的数据结构是使用的是链表结构，特点：增删快，查询较慢。
                    堆栈：先进后出，如同一个杯子。
                    队列：先进先出，如同一个水管。
                vector：
                    底层是数组数据结构，是线程同步的，呗arraylist替代了。
                    特别的支持枚举。
            set
             元素是无序(存入的和取出的不一样标识无序)的，元素不可以重复。
                hashset：底层数据结构是使用的哈希表结构
                        那么针对元素不重复，hashset是如何保证的？
                        原理：主要是通过元素的hashcode方法和equals方法来完成
                        在进行添加元素的时候
                        如果元素的hashcode值相同，才会判断equals是否为true。
                        如果元素的hashcode值不同，不会调用equals方法。
                    对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashCode方法和equals方法。
                    线程不同步
                treeset：底层数据结构是使用二叉树，
                    可以对set集合中的元素进行排序
                    其原理：
                    排序方式：
                        1. 让元素自身具备比较性，袁旭需要实现Comparable接口，覆盖compareTo方法

        map：
             hashtable：
                    底层是哈希表数组结构，不可以存储null键和null值，该集合是线程同步的
             hashmap：
                    底层是哈希表数据结构，允许使用null键和null值，该集合不同步
             treemap：
                    底层是二叉树数据结构，线程不同步，可以用于给map集合中的键进行排序

         */
    public static void main(String[] args) throws Exception {
        Woman woman = new Woman();



    }

}



